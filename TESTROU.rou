 ;**************************
 ;* ANSI M Level Unit Test
 ;**************************
 ; Author: Chris Rink
 ;
TESTROU ;
 n fails
 ;
 ; Nice welcome message before the beat drops
 w "---------------------------------------------------------"
 w "Welcome to MUMPy!"
 w "This script will run the MUMPS-side Unit Tests for MUMPy."
 w "---------------------------------------------------------"
 w "Hold on..."
 ;
 ; Check that EQUALS comparisons are working, quit if not.
 q:($$TestEquals())
 q:($$TestLogic())
 ;
 ; Likewise, we will need Regular and Pointer function arguments to work
 q:($$TestRegularArgs())
 q:($$TestPointerArgs())
 ;
 ; Perform tests
 s fails=fails+$$TestArithmetic()
 s fails=fails+$$TestStringOp()
 s fails=fails+$$TestIfElse()
 s fails=fails+$$TestIntrinsic()
 ;
 ; Report the results
 w "---------------------------------------------------------"
 w:(fails=1) "There was 1 test which failed."
 w:(fails>1) "There were "_fails_" tests which failed."
 w:(fails=0) "Success!"
 w "---------------------------------------------------------"
 q
 ;
 ;**************************
 ;* Test utility function
 ;**************************
 ; Input the result from the test and the expected value.
 ; Pass in the failure count as a pointer and an error message.
 ; If the test fails, the failure count will increment and the
 ; message will be output to the current device.
EvalTest(res,exp,fails,msg) ;
 q:(res=exp)
 s fails=fails+1
 w msg_" >>> res="_res_" exp="_exp
 q
 ;
 ;**************************
 ;* Equals Tests
 ;**************************
 ; The rest of the tests are invalid if equals doesn't work since we
 ; use the equals and not equals operators to check if a test succeeded.
TestEquals() ;
 n val,msg
 s msg="Equals failed. Quitting"
 i '(1=1) w msg q 1
 s val=(1'=1)
 i val=1 w msg q 1
 q 0
 ;
 ;**************************
 ;* Logic Tests
 ;**************************
TestLogic() ;
 n val
 ;
 w "Testing logical NOT..."
 s val='1 q:(val=1) 1
 w "Testing logical NOT..."
 s val='0 q:(val=0) 1
 ;
 w "Testing logical AND..."
 s val=(1&1) q:(val=0) 1
 s val=(1&0) q:(val=1) 1
 s val=(0&0) q:(val=1) 1
 ;
 w "Testing logical NOT AND..."
 s val=(1'&1) q:(val=1) 1
 s val=(1'&0) q:(val=0) 1
 s val=(0'&0) q:(val=0) 1
 ;
 w "Testing logical OR..."
 s val=(1!1) q:(val=0) 1
 s val=(1!0) q:(val=0) 1
 s val=(0!0) q:(val=1) 1
 ;
 w "Testing logical NOT OR..."
 s val=(1'!1) q:(val=1) 1
 s val=(1'!0) q:(val=1) 1
 s val=(0'!0) q:(val=0) 1
 ;
 q 0
 ;
 ;**************************
 ;* Regular Argument Tests
 ;**************************
 ; We need to make sure that sub-nodes for values do not get passed in for
 ; non-pointer types of arguments. Since the correct evaluation of these
 ; tests depends on this, we need to check this early.
TestRegularArgs() ;
 n val,name,fail
 w "Testing regular arguments..."
 s val=1
 s name="Chris"
 s name("last")="Rink"
 s fail=$$testRegArgs(val,name)
 q:(fail=0) 0
 w "[FAIL]"
 q 1
 ;
testRegArgs(val,name) ;
 q:(val'=1) 1
 q:(name'="Chris") 1
 q:(name("last")'="") 1
 q 0
 ;
 ;**************************
 ;* Pointer Argument Tests
 ;**************************
 ; Pointer arguments are also used for the test evaluator, so we'll need
 ; to make sure that these work.
TestPointerArgs() ;
 n val,name
 w "Testing pointer arguments..."
 ;
 ; Test that calling functions receive modifications to pointer arguments
 s val=1
 d testPtrArgs(.val)
 i val'=6 w "[FAIL]" q 1
 ;
 ; Test that pointer arguments also pass the subnode access
 s name="Chris"
 s name("Last")="Rink"
 s name("Last","Suffix")="Jr"
 s name("MI")="L"
 i $$testPtrArgs4(.name) w "[FAIL]" q 1
 q 0
 ;
testPtrArgs(arg) ;
 s arg=arg+1
 d testPtrArgs2(.arg)
 q
testPtrArgs2(arg) ;
 s arg=arg+1
 d testPtrArgs3(.arg)
 q
testPtrArgs3(param) ;
 s param=param*2
 q
testPtrArgs4(arg) ;
 q:(arg'="Chris") 1
 q:(arg("Last")'="Rink") 1
 q:(arg("Last","Suffix")'="Jr") 1
 q:(arg("MI")'="L") 1
 q 0
 ;
 ;**************************
 ;* Expression Tests
 ;**************************
TestArithmetic() ;
 n res,exp,fail,msg
 w "Testing arithmetic..."
 ;
 ; Test unary PLUS operators
 s msg=" - A unary PLUS operator failed"
 d EvalTest(+1,1,.fail,msg)
 d EvalTest(+"27 apples",27,.fail,msg)
 d EvalTest(+++---+--+3,-3,.fail,msg)
 d EvalTest(+"+++---+--+3",-3,.fail,msg)
 d EvalTest(+"+++---+--+3.5",-3.5,.fail,msg)
 d EvalTest(+"+++---+--+3.5.5",-3.5,.fail,msg)
 ;
 ; Test unary MINUS operators
 s msg=" - A unary MINUS operator failed"
 d EvalTest(-1,-1,.fail,msg)
 d EvalTest(-"27 apples",-27,.fail,msg)
 d EvalTest(+++--+--+3,3,.fail,msg)
 d EvalTest(-"+++---+--+3",3,.fail,msg)
 d EvalTest(-"+++---+--+3.5",3.5,.fail,msg)
 d EvalTest(-"+++---+--+3.5.5",3.5,.fail,msg)
 ;
 ; Test addition
 s msg=" - An addition operation failed"
 d EvalTest(1+4,5,.fail,msg)
 d EvalTest((-3)+(-4),-7,.fail,msg)
 d EvalTest("2 apples"+"3 oranges",5,.fail,msg)
 ;
 ; Test subtraction
 s msg=" - A subtraction operation failed"
 d EvalTest(1-4,-3,.fail,msg)
 d EvalTest(7-2,5,.fail,msg)
 d EvalTest("5 apples"-"3 oranges",2,.fail,msg)
 ;
 ; Test multiplication
 s msg=" - Multiplication failed."
 d EvalTest(3*3,9,.fail,msg)
 d EvalTest(7.5*2,15,.fail,msg)
 d EvalTest(-2.5*2.5,-6.25,.fail,msg)
 d EvalTest(2.5*-2.5,-6.25,.fail,msg)
 d EvalTest((-3)*(-4),12,.fail,msg)
 d EvalTest("5 apples"*"3 oranges",15,.fail,msg)
 ;
 ; Test division
 s msg=" - Division failed."
 d EvalTest(9/3,3,.fail,msg)
 d EvalTest(5/2,2.5,.fail,msg)
 d EvalTest(5/-2,-2.5,.fail,msg)
 d EvalTest(-5/2,-2.5,.fail,msg)
 d EvalTest(1/128,0.0078125,.fail,msg)                  ; #TODO: handle decimal args with no leading zero
 d EvalTest("15 apples"/"3 oranges",5,.fail,msg)
 ;
 ; Test integer division
 s msg=" - Integer division failed."
 d EvalTest(9\3,3,.fail,msg)
 d EvalTest(5\2,2,.fail,msg)
 d EvalTest(-5\2,-2,.fail,msg)
 d EvalTest(1\2,0,.fail,msg)
 d EvalTest(-1\2,0,.fail,msg)
 d EvalTest(1\3*3,0,.fail,msg)
 ;
 ; Test modulo operator
 s msg=" - Modulo operation failed."
 d EvalTest(-9#5,1,.fail,msg)
 d EvalTest(-3#5,2,.fail,msg)
 d EvalTest(-6#-5,-1,.fail,msg)
 d EvalTest(4#-5,-1,.fail,msg)
 ;
 ; Test power operator
 s msg=" - Exponentiation failed."
 d EvalTest(32**.2,2,.fail,msg)
 d EvalTest(2**5,32,.fail,msg)
 d EvalTest(16**.25,2,.fail,msg)
 d EvalTest(2**3**4,4096,.fail,msg)
 d EvalTest(4**(-2),0.0625,.fail,msg)
 d EvalTest(27**(1/3),3,.fail,msg)
 ;
 q +fail
 ;
 ;**************************
 ;* String Operator Tests
 ;**************************
TestStringOp() ;
 q 0
 ;
 ;**************************
 ;* Intrinsic Tests
 ;**************************
TestIntrinsic() ;
 q 0
 ;
 ;**************************
 ;* IF/ELSE Tests
 ;**************************
TestIfElse() ;
 n val,fail
 w "Testing IF/ELSE..."
 ;
 ; Verify that ELSE doesn't fire initially ($T is true on env start)
 e  s fail=fail+1 w "$T not properly set."
 ;
 ; Verify that ELSE doesn't fire if $T is true
 i 1 s val=0
 e  s fail=fail+1 w "ELSE failed."
 ;
 ; Verify that an argumentless IF will succeed since $T is still true
 i  s val=1
 i val'=1 s fail=fail+1 w "Argumentless IF failed."
 ;
 ; Verify that ELSE does fire if $T is false
 i 0 s fail=fail+1 w "IF failed."
 e  s val=0
 ;
 q +fail
 ;
 q